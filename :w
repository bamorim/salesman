def improvePath(G,initial_path):
    path = initial_path
    cost = G.pathCost(path)
    edgeCost = lambda a,b: G.getEdge(a,b)[2]
    for i in range(0,len(G)):
        for j in range(i+1,len(G)):
            if swapCost(G,path,i,j) < 0:
                swap2op(path,i,j)
                return True
    return False
    return path

def improveCost(G,path,i,j):
    ij1 = G.getEdge( path[i], path[j-1] )[2]
    i1j = G.getEdge( path[i-1], path[j] )[2]
    ii1 = G.getEdge( path[i], path[i-1] )[2]
    jj1 = G.getEdge( path[j], path[j-1] )[2]
    return ij1 + i1j - ii1 - jj1

# In place swap for performance
def swap2op(path,i,j):
    path[i:j] = path[i:j][::-1]
